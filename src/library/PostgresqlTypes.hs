-- |
-- Haskell representations of PostgreSQL data structures in their canonical forms that directly correspond to their PostgreSQL definitions. No data loss.
--
-- These types do not necessarily have direct mappings to the common Haskell types. E.g., any @text@ value from PostgreSQL makes valid 'Data.Text.Text' values in Haskell, but not every Haskell 'Data.Text.Text` value makes valid PostgreSQL @text@, because PostgreSQL does not allow NUL-bytes in text fields, but Haskell's 'Data.Text.Text' does. In case of dates the supported date ranges may differ between PostgreSQL and Haskell's \"time\" library. Therefore, conversions between these types and common Haskell types may be partial and may fail if the data cannot be represented in the target type.
--
-- = Type Categories
--
-- The types are organized into the following categories:
--
-- == Numeric Types
--
-- * 'Int2' - 2-byte signed integer (@int2@ \/ @smallint@)
-- * 'Int4' - 4-byte signed integer (@int4@ \/ @integer@)
-- * 'Int8' - 8-byte signed integer (@int8@ \/ @bigint@)
-- * 'Float4' - Single-precision floating point (@float4@ \/ @real@)
-- * 'Float8' - Double-precision floating point (@float8@ \/ @double precision@)
-- * 'Numeric' - Arbitrary precision numeric (@numeric@ \/ @decimal@)
-- * 'Money' - Currency amount (@money@)
-- * 'Oid' - Object identifier (@oid@)
--
-- == Character Types
--
-- * 'Text' - Variable-length character string (@text@)
-- * 'Varchar' - Variable-length with limit (@varchar@)
-- * 'Char' - Single ASCII character (@char@)
-- * 'Bpchar' - Fixed-length character string (@char(n)@, @character(n)@, or @bpchar(n)@)
--
-- == Boolean Type
--
-- * 'Bool' - Boolean (@bool@)
--
-- == Binary Data
--
-- * 'Bytea' - Binary data (@bytea@)
--
-- == Date\/Time Types
--
-- * 'Date' - Calendar date (@date@)
-- * 'Time' - Time of day without time zone (@time@)
-- * 'Timestamp' - Date and time without time zone (@timestamp@)
-- * 'Timestamptz' - Date and time with time zone (@timestamptz@)
-- * 'Timetz' - Time of day with time zone (@timetz@)
-- * 'TimetzAsTimeOfDayAndTimeZone' - Alternative representation of @timetz@
-- * 'Interval' - Time interval (@interval@)
-- * 'IntervalAsMicroseconds' - Interval as microseconds
--
-- == Network Address Types
--
-- * 'Inet' - IPv4 or IPv6 host address (@inet@)
-- * 'Cidr' - IPv4 or IPv6 network address (@cidr@)
-- * 'Macaddr' - MAC address (@macaddr@)
-- * 'Macaddr8' - MAC address (EUI-64 format) (@macaddr8@)
-- * 'Ip' - Generic IP address type
--
-- == Geometric Types
--
-- * 'Point' - Point on a plane (@point@)
-- * 'Line' - Infinite line (@line@)
-- * 'Lseg' - Line segment (@lseg@)
-- * 'Box' - Rectangular box (@box@)
-- * 'Path' - Geometric path (@path@)
-- * 'Polygon' - Closed geometric path (@polygon@)
-- * 'Circle' - Circle (@circle@)
--
-- == Bit String Types
--
-- * 'Bit' - Fixed-length bit string (@bit@)
-- * 'Varbit' - Variable-length bit string (@varbit@)
--
-- == UUID Type
--
-- * 'Uuid' - Universally unique identifier (@uuid@)
--
-- == JSON Types
--
-- * 'Json' - JSON data (@json@)
-- * 'Jsonb' - Binary JSON data (@jsonb@)
--
-- == Key-Value Types
--
-- * 'Hstore' - Key-value store (@hstore@)
--
-- == Range Types
--
-- * 'Range' - Generic range type (@int4range@, @int8range@, @numrange@, @tsrange@, @tstzrange@, @daterange@)
-- * 'Multirange' - Generic multirange type (@int4multirange@, @int8multirange@, etc.)
--
-- = Type Conversions
--
-- These types do not necessarily have direct mappings to common Haskell types,
-- but they provide lawful conversions to and from them using the
-- [lawful-conversions](https://hackage.haskell.org/package/lawful-conversions) library.
--
-- The library provides several conversion typeclasses:
--
-- * 'IsSome' - Partial conversion that may fail (like @Text -> Maybe PostgresqlTypes.Text@)
-- * 'IsMany' - Total conversion that always succeeds (like @Int32 -> PostgresqlTypes.Int4@)
-- * 'Is' - Bidirectional conversion combining both directions
--
-- Each type also implements 'IsScalar' which provides binary and textual
-- encoding/decoding according to PostgreSQL's wire protocol specification.
--
-- = Usage Examples
--
-- > import LawfulConversions
-- > import qualified Data.Text as Text
-- > import qualified Data.Time as Time
-- > import qualified PostgresqlTypes.Types as PG
-- >
-- > -- Total conversion (IsMany): Int32 -> Int4 (always succeeds)
-- > pgInt :: PG.Int4
-- > pgInt = from @Int32 42
-- >
-- > -- Extract Int32 from Int4
-- > hsInt :: Int32
-- > hsInt = to @Int32 pgInt
-- >
-- > -- Partial conversion (IsSome): Text -> PostgreSQL Text. May fail if contains NUL-bytes, because PostgreSQL does not allow NUL-bytes in text fields.
-- > pgTextMaybe :: Maybe PG.Text
-- > pgTextMaybe = maybeFrom @PG.Text (Text.pack "Hello")
-- >
-- > -- Same conversion done using (IsMany), which canonicalizes the input text by throwing away the NUL-bytes, because PostgreSQL Text cannot contain NULs.
-- > pgText :: PG.Text
-- > pgText = onfrom @PG.Text (Text.pack "Hello")
-- >
-- > -- Total conversion with normalization: Day -> Date (clamps to valid range)
-- > pgDate :: PG.Date
-- > pgDate = onfrom @Time.Day (Time.fromGregorian 2024 1 15)
-- >
-- > -- Extract Day from Date
-- > hsDay :: Time.Day
-- > hsDay = to @Time.Day pgDate
--
-- For more information:
--
-- * [PostgreSQL type documentation](https://www.postgresql.org/docs/current/datatype.html)
-- * [lawful-conversions library](https://hackage.haskell.org/package/lawful-conversions)
module PostgresqlTypes
  ( module PostgresqlTypes.Types,
  )
where

import PostgresqlTypes.Types
